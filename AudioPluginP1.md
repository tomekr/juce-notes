Note that for the tutorial, we want MIDI input and output so that’s why we do step #4

## Steps Taken
1. In Projucer click File > New Project
2. Give it a name
3. Check VST3 (and AU)
4. Check “Plug-in wants midi input and Plug-in produces midi output”
5. Click the “Save and Open in IDE button”

From here XCode opens

## Set up plug-in debugging

We can configure the host to enable step-through debugging of your plugin. To do this:

1. Go to your plug-in project in Xcode, click Product > Scheme > Edit Scheme
2. Under Run, from the Executable dropdown select Other... and locate the Plugin Host.app binary. 
3. Make sure Debug executable is ticked.

Now when you build and run your plugin within Xcode it will automatically launch the host, and when your plug-in is loaded inside the host you can set breakpoints and do step-through debugging.

## File Structure for a JUCE Plugin

A newly-created audio plug-in project contains two main classes"

* **PluginProcessor:** handles the audio and MIDI IO and processing logic
* **PluginEditor:** handles any on screen GUI controls or visualisations

When passing information between these two it is best to consider the processor as the parent of the editor. There is only one plug-in processor whereas you can create multiple editors.

Each editor has a reference to the processor such that it can edit or access information and parameters from the audio thread. It is the editor’s job to set and get information on this processor thread and not the other way around.

### PluginProcessor.cpp

The main function we will be editing in the PluginProcessor.cpp file is the `processBlock()` method.

* This receives and produces both audio and MIDI data to the plug-in output.

### PluginEditor.cpp

In this file's constructor (usually found in the header file), we initialise and set up our window and GUI objects, and also the paint() method (in the cpp file) where we can draw extra controls and custom GUI components.

### Linking interactions in the Editor with the Processor

In order to get the slider value to control the MIDI effect on the processor thread we need to create a new variable on the processor thread that we can use the slider to change.

In other words, we're going to declare and initialize a **public** variable that will be accessible by the Editor thread

```c++
// This is in PluginProcessor.h
public:
	 // This is the variable that we will set with the slider
    float noteOnVel;
```

Add a listener and callback to the PluginEditor

```c++
// This is in PluginEditor.h
class TutorialPluginAudioProcessorEditor : public AudioProcessorEditor,
                                           private Slider::Listener
{
public:
    // Original untouched code
 
private:
    void sliderValueChanged (Slider* slider) override;
    
    // Rest of code
};
```
Now we add the slider listener to our volume slider in the editor constructor:



## Basic flow for adding a new component

First, Declare and initialize it in the `pirvate` block of the constructor in the header file. In the example below, we're adding a midiVolume Slider (all the other code was already there).

```c++
// This is the constructor declaration in PluginEditor.h
class NewProjectAudioProcessorEditor  : public AudioProcessorEditor
{
public:
    NewProjectAudioProcessorEditor (NewProjectAudioProcessor&);
    ~NewProjectAudioProcessorEditor();

    //==============================================================================
    void paint (Graphics&) override;
    void resized() override;

private:
    // This reference is provided as a quick way for your editor to
    // access the processor object that created it.
    NewProjectAudioProcessor& processor;
    
    Slider midiVolume;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NewProjectAudioProcessorEditor)
};
```

Then, configure and setup the component and it's various properties in the constructor in the CPP file. It is here that we also add it to the editor with something like `addAndMakeVisible (&midiVolume);`

```c++
// This is the constructor implementation in PluginEditor.cpp
NewProjectAudioProcessorEditor::NewProjectAudioProcessorEditor (NewProjectAudioProcessor& p)
    : AudioProcessorEditor (&p), processor (p)
{
    // Make sure that before the constructor has finished, you've set the
    // editor's size to whatever you need it to be.
    setSize (200, 200); // This was already generated by Projucer
    
    // these define the parameters of our slider object
    midiVolume.setSliderStyle (Slider::LinearBarVertical);
    midiVolume.setRange(0.0, 127.0, 1.0);
    midiVolume.setTextBoxStyle (Slider::NoTextBox, false, 90, 0);
    midiVolume.setPopupDisplayEnabled (true, this);
    midiVolume.setTextValueSuffix (" Volume");
    midiVolume.setValue(1.0);
    
    // this function adds the slider to the editor
    addAndMakeVisible (&midiVolume);
}
```
Then set the size and position of our component in the `resized()` method:

```c++
// This method is in PluginEditor.cpp
void NewProjectAudioProcessorEditor::resized()
{
    // This is generally where you'll want to lay out the positions of any
    // subcomponents in your editor..
    
    // sets the position and size of the slider with arguments (x, y, width, height)
    midiVolume.setBounds (40, 30, 20, getHeight() - 60);
}
```

### **It is at this point that the component will be visible on the screen when you run your plugin**

## Plugin vs Standalone App
The `AudioProcessorEditor` (found in the `PluginEditor`) plays the same role in an Audio Plug-in that the main content component has in a standalone app.

## The Component class

The most important base class for all JUCE graphical interfaces is the Component class. In JUCE, practically all visible elements of the GUI, be it buttons, sliders, or text fields, are components, deriving from this class. 

The way to write such an app in JUCE is to create a main component, which is owned by the main application window and is the window's content. All other components will then be children of this main component